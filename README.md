# Отчёт по ocl2. "Префиксная сумма".
### Цель работы:
Реализовать эффективную программу, выполняющую вычисление префиксной суммы с использованием OpenCL (версия 1.2).
### Описание задания:
Вычислить префиксную сумму (inclusive prefix sum) со значениями типа float.
#
### Формат входного файла:
n

/* массив из n элементов, разделённых пробелом */
Пример:

5

1.0 2 3. 4.0 5.6
#
### Формат вывода результата

/* массив из n элементов, разделённых пробелом */

Пример:

1 3 6 10 15.6
#
## Ход работы:
### *Начальная настройка*
Для начала работы с OpenCL в проекте были подключены библиотеки через:
Проект ---> Свойства
Зайдя в: "Свойства конфигурации ---> C/C++ --->  Общие" необходимо подключить в дополнительные каталоги OpenCL SDK. Там же на всякий случай была отключена проверка SDL, ибо прошлый опыт показывал, что порой предупреждения (warnings) фреймворка OpenCL воспринимались в VS как ошибки, из-за чего VS не давал компилировать код.
В "C/C++ --->  Язык" можно включить поддержу Open MP, чтобы потом применить его к коду, работающему на хосте.
Вернувшись в "Свойства конфигурации ---> Компоновщик" в дополнительные каталоги библиотек также была указана папка с OpenCL SDK, а в "Компоновщик ---> Ввод" в дополнительных зависимостях указан файл OpenCL.lib.
В программу мы будем передавать аргументы через командную строку, в случае VS это делается в "Свойства конфигурации ---> Отладка", команда пишется в поле "Аргументы команды". Поэтому, необходимо настроить рабочий каталог. Можно указать его вручную в поле "Рабочий каталог" или выбрать обзор, в котором нужно указать корневую папку.

### *Аргументы команды*
Программе передаются следующие аргументы:
Входной файл указывается через --input <название файла>
Выходной файл указывается через --output <название файла>
Тип девайса через --device-type <тип (cpu, gpu, igpu, dgpu, all)>
Индекс девайса через --device-index <индекс (от 0 до максимума, к примеру, при наличии интегрированной и дискретной видеокарты индексы будут: 0 - интегрированная, 1 - дискретная)>

Для начала, можно преобразовать строковое представление типа устройства в соответствующее значение, используемое в OpenCL, введя функцию,  которая будет принимать строку и возвращать значение типа **cl_device_type**. В библиотеке OpenCL есть значения, которыми можно обозначить типы устройств:
**CL_DEVICE_TYPE_CPU** - обозначает процессор,
**CL_DEVICE_TYPE_GPU** - обозначает видеокарту как интегрированную, так и дискретную,
**CL_DEVICE_TYPE_ALL** - обозначает все типы устройств.

Теперь нужно сделать так, чтобы как-то упорядочить наши устройства. К примеру, программа не понимает, какую видеокарту нам нужно выбрать, интегрированную или дискретную. Или каков вообще порядок при выборе типа девайса как ALL?
Заведём функцию, принимающую идентификатор платформы OpenCL, тип устройства в системе и строковое его написание.
Объявим переменную, для хранения количества устройств, которую используем в функции **clGetDeviceIDs**, которая запрашивает количество устройств указанного типа на платформе.
Создадим вектор для хранения идентификаторов устройств, чтобы функция **clGetDeviceIDs** заполнила его.
Теперь надо разобраться с видеокартами. Я был в шоке, когда узнал, что у дискретной видеокарты есть своя память, а у интегрированной нет. На этом можно сыграть, получив информацию об устройстве, использует ли оно общую память, что свойственно интегрированной видеокарте. После чего записываем устройства в вектор.
В теле нашей основной **main** функции тем временем определим, какие команды должны приниматься в программе через `argc` —  это количество аргументов, `argv` — это массив строк с аргументами. Можно сделать через парсинг аргументов, создав словарь `map` для хранения пар “ключ-значение” аргументов. Заводим переменные для типа устройств, индекса, входного и выходного файла и не забываем делать проверки на случай, если аргумент неправильно задан. 
Теперь займёмся сортировкой всех типов устройств при `--device-type all`:
Можно создать вектор пар, где каждая пара состоит из идентификатора устройства и индекса, который будет использоваться для сортировки. Проходимся по всем устройствам и получаем их типы. Затем определяем индексы для сортировки так, чтобы был такой порядок: 0 - дискретная видеокарта, 1 - интегрированная видеокарта, 2 - процессор. Ну, и, 3 - остальные устройства. Сортируем вектор по второму элементу пары (индексу) и создаем вектор для хранения уже отсортированных устройств. Сделаем также проверку, чтобы на случай, если индекс устройства выходит за пределы списка, выводилось сообщение об ошибке. Выведем также имя выбранного устройства и индекс.

### *Чтение файлов*

Займёмся чтением файлов. Сделать это можно с помощью `ifstream`. Сделаем проверку на то, открылся ли файл.
Так как будем закрывать файл, можно сразу для нашей задачи прочитать количество элементов **n** в нём. Создадим вектор, прочитаем количество элементов и изменим размер вектора для их хранения. Через цикл `for` можно прочитать каждый элемент из файла, после чего закроем файл.

С помощью той же команды `ifstream` прочитаем файл с нашим ядром `kernel.cl`. 

### *Работа с OpenCL*

Теперь пора настроить работу нашей программы с использованием OpenCL. 
Основные этапы: 
1.  *Создаем контекст для исполнения нашей программы на выбранном устройстве.*
2.  *Создаем очередь команд на основе контекста и ID устройства.*
3.  *Создаем программу на основе исходного кода ядра и контекста.*
4.  *Создаем буферы для входных и выходных данных, предварительно определив размеры локальной и глобальной групп*
5.  *Собираем программу (build).*
6.  *Создаем сам kernel.*
7. *Задаем аргументы, которые мы передадим в ядро*
8.  *Ставим в очередь команду записи данных из области памяти с данными на хосте в память устройства.*
9.  *Ставим в очередь команду исполнения созданного нами kernel.*
10.  *Ставим в очередь команду считывания данных из устройства.*
11.  *Ждем завершения операций.*

В данной работе, будет использоваться 3 буфера. Первый для входного массива, второй для массива, который будет сохранять префиксные суммы, а третий для суммы предыдущих групп.

После выполнения ядра читаем результат и записываем его в выходной файл через `ofstream` и закрываем его.

Выводим время работы ядра с помощью команды `clGetEventProfilingInfo`, положив в него `event`, который можно задать предварительно через`cl_event` , также выводим размер локальной группы.
Следует проследить, чтобы третий аргумент в `clEnqueueReadBuffer` был выставлен как **CL_TRUE**, который позволяет считывать информацию о времени работы.

В конце освобождаем ресурсы с помощью `clRelease` -     `clReleaseMemObject(<название буфера>); clReleaseKernel(kernel); clReleaseEvent(event); clReleaseProgram(program); clReleaseCommandQueue(commandQueue); clReleaseContext(context);`

## *Префиксная сумма в kernel*

Все вычисления префиксной суммы проходят в ядре kernel. 
Стоит начать с того, что префиксная сумма - это алгоритм, который находит кумулятивные суммы элементов массива. То есть, для массива $[a_0,a_1,a_2,…,a_n]$ префиксная сумма вычисляется как $[a_0,a_0+a_1,a_0+a_1+a_2,…]$

Основная идея алгоритма взята с алгоритма под названием Blelloch scan, который является одним из вариантов параллельного сканирования (префиксной суммы). Он выполняется в два этапа: **up-sweep (редукция)** и **down-sweep (коррекция)**

Мой алгоритм разбивает задачу на две фазы:

1.  **Параллельное вычисление локальных префиксных сумм внутри рабочих групп.** Каждая рабочая группа (локальная группа) вычисляет префиксные суммы для своего участка данных, используя локальную память для временного хранения промежуточных результатов.
2.  **Коррекция глобальных сумм с учетом сумм предыдущих групп.** После того как все локальные префиксные суммы вычислены, результаты корректируются с учетом префиксных сумм предыдущих групп для получения окончательного результата.

### Схематичное представление:
Пусть элементов всего 8, а размер локальной группы 2:

### Входные данные:

-   Входной массив: `[1, 2, 3, 4, 5, 6, 7, 8]`
-   Размер локальной группы: `2`
-   Всего элементов: `8`

### Инициализация и загрузка данных в локальную память

-   Глобальный ID (`gid`) варьируется от 0 до 3 (поскольку каждая рабочая группа обрабатывает по 2 элемента).
-   Локальный ID (`lid`) варьируется от 0 до 1 (так как локальная группа из 2 потоков).

Копирование данных в локальную память `local_data`:

-   Группа 0 (элементы 0 и 1): `local_data[0] = 1, local_data[1] = 2`
-   Группа 1 (элементы 2 и 3): `local_data[0] = 3, local_data[1] = 4`
-   Группа 2 (элементы 4 и 5): `local_data[0] = 5, local_data[1] = 6`
-   Группа 3 (элементы 6 и 7): `local_data[0] = 7, local_data[1] = 8`

### Фаза up-sweep (редукция)

Цель этой фазы — накопить суммы внутри локальной памяти каждой группы.

#### Итерация 1 (`step = 1`):

-   `lid = 0`: Суммируем `local_data[1] += local_data[0]`

Результаты:

-   Группа 0: `local_data[0] = 1, local_data[1] = 3` (1 + 2)
-   Группа 1: `local_data[0] = 3, local_data[1] = 7` (3 + 4)
-   Группа 2: `local_data[0] = 5, local_data[1] = 11` (5 + 6)
-   Группа 3: `local_data[0] = 7, local_data[1] = 15` (7 + 8)

### Сохранение последнего элемента группы

Сохраняем последний элемент каждой локальной группы в глобальную память `group_sums`:

-   `group_sums[0] = 3`
-   `group_sums[1] = 7`
-   `group_sums[2] = 11`
-   `group_sums[3] = 15`

### Коррекция результатов (фаза down-sweep)

Фаза корректировки идет через накопление сумм из массива `group_sums`.

#### Итерация 1: Коррекция второй группы

-   Группа 1 (с использованием суммы из Группы 0):
    -   `output[2] += 3` -> `output[2] = 3 + 3 = 6`
    -   `output[3] += 3` -> `output[3] = 7 + 3 = 10`

#### Итерация 2: Коррекция третьей группы

-   Группа 2 (с использованием суммы из Групп 0 и 1):
    -   `output[4] += 10` -> `output[4] = 5 + 10 = 15`
    -   `output[5] += 10` -> `output[5] = 11 + 10 = 21`

#### Итерация 3: Коррекция четвертой группы

-   Группа 3 (с использованием суммы из Групп 0, 1 и 2):
    -   `output[6] += 21` -> `output[6] = 7 + 21 = 28`
    -   `output[7] += 21` -> `output[7] = 15 + 21 = 36`

### Результат:

После выполнения кода префиксная сумма выглядит так:

*1 3 6 10 15 21 28 36*

# *Тесты*:
Компьютер: Ноутбук HP Gaming Pavilion 15-ec1063ur (22N74EA)
Процессор: AMD Ryzen7 4800H 2900 МГц
Видеокарта: Nvidia GeForce GTX 1660Ti 6 ГБ
RAM: 2x8 ГБ 3200 МГц

Индексы девайсов и их названия:
0 - dgpu - NVIDIA GeForce GTX 1660 Ti with Max-Q Design
1 - igpu - gfx90c
2 - cpu - AMD Ryzen 7 4800H with Radeon Graphics

| device-index |   n   | LOC_SIZE | Time(ms) |
|:------------:|:-----:|:--------:|:--------:|
| 0 (dgpu)     | 1024  | 2        | 0.022784 |
|              | 1024  | 4        | 0.015424 |
|              | 1024  | 8        | 0.011904 |
|              | 1024  | 16       | 0.01024  |
|              | 1024  | 32       | 0.0096   |
|              | 1024  | 64       | 0.01008  |
|              | 2048  | 2        | 0.05536  |
|              | 2048  | 4        | 0.02288  |
|              | 2048  | 8        | 0.014944 |
|              | 2048  | 16       | 0.010656 |
|              | 2048  | 32       | 0.01024  |
|              | 2048  | 64       | 0.00896  |
|              | 4096  | 2        | 0.180224 |
|              | 4096  | 4        | 0.056    |
|              | 4096  | 8        | 0.023904 |
|              | 4096  | 16       | 0.014848 |
|              | 4096  | 32       | 0.012288 |
|              | 4096  | 64       | 0.010656 |
|              | 8192  | 2        | 0.669536 |
|              | 8192  | 4        | 0.183808 |
|              | 8192  | 8        | 0.057344 |
|              | 8192  | 16       | 0.024576 |
|              | 8192  | 32       | 0.014784 |
|              | 8192  | 64       | 0.012608 |
|              | 16384 | 2        | 2.58867  |
|              | 16384 | 4        | 1.19248  |
|              | 16384 | 8        | 0.183104 |
|              | 16384 | 16       | 0.058976 |
|              | 16384 | 32       | 0.025632 |
|              | 16384 | 64       | 0.018432 |
| 1 (igpu)     | 1024  | 2        | 0.10756  |
|              | 1024  | 4        | 0.03828  |
|              | 1024  | 8        | 0.02156  |
|              | 1024  | 16       | 0.01396  |
|              | 1024  | 32       | 0.01128  |
|              | 1024  | 64       | 0.01008  |
|              | 2048  | 2        | 0.3446   |
|              | 2048  | 4        | 0.10632  |
|              | 2048  | 8        | 0.03212  |
|              | 2048  | 16       | 0.02268  |
|              | 2048  | 32       | 0.01472  |
|              | 2048  | 64       | 0.01108  |
|              | 4096  | 2        | 1.25128  |
|              | 4096  | 4        | 0.34532  |
|              | 4096  | 8        | 0.10888  |
|              | 4096  | 16       | 0.03944  |
|              | 4096  | 32       | 0.02344  |
|              | 4096  | 64       | 0.01556  |
|              | 8192  | 2        | 4.8502   |
|              | 8192  | 4        | 1.2564   |
|              | 8192  | 8        | 0.3496   |
|              | 8192  | 16       | 0.11164  |
|              | 8192  | 32       | 0.04016  |
|              | 8192  | 64       | 0.02488  |
|              | 16384 | 2        | 19.4122  |
|              | 16384 | 4        | 4.85624  |
|              | 16384 | 8        | 1.26448  |
|              | 16384 | 16       | 0.3574   |
|              | 16384 | 32       | 0.1134   |
|              | 16384 | 64       | 0.04084  |
| 2 (cpu)      | 1024  | 2        | 0.5296   |
|              | 1024  | 4        | 0.4466   |
|              | 1024  | 8        | 0.4754   |
|              | 1024  | 16       | 0.7789   |
|              | 1024  | 32       | 0.4204   |
|              | 1024  | 64       | 0.4632   |
|              | 2048  | 2        | 1.2812   |
|              | 2048  | 4        | 0.7085   |
|              | 2048  | 8        | 0.5372   |
|              | 2048  | 16       | 0.6505   |
|              | 2048  | 32       | 0.4321   |
|              | 2048  | 64       | 0.1142   |
|              | 4096  | 2        | 1.3854   |
|              | 4096  | 4        | 0.9398   |
|              | 4096  | 8        | 0.4084   |
|              | 4096  | 16       | 0.5651   |
|              | 4096  | 32       | 0.5191   |
|              | 4096  | 64       | 0.4181   |
|              | 8192  | 2        | 2.2002   |
|              | 8192  | 4        | 2.0761   |
|              | 8192  | 8        | 1.274    |
|              | 8192  | 16       | 1.3609   |
|              | 8192  | 32       | 1.0639   |
|              | 8192  | 64       | 0.4898   |
|              | 16384 | 2        | 4.9612   |
|              | 16384 | 4        | 2.9501   |
|              | 16384 | 8        | 1.0723   |
|              | 16384 | 16       | 0.7997   |
|              | 16384 | 32       | 0.5949   |
|              | 16384 | 64       | 0.6668   |

![dgpu](https://i.postimg.cc/W4f7gBB2/dgpu.png)
![igpu](https://i.postimg.cc/Ss2frZ4c/igpu.png)![cpu](https://i.postimg.cc/bvvTGyFC/cpu.png)
Как и ожидалось, при увеличении размера локальной группы скорость возрастает, а с увеличением **n** скорость уменьшается. Было замечено, что вычисления на дискретной и интегральной видеокарте происходят с намного меньшей погрешностью во времени, чем на процессоре.  

Сервер:
Индексы девайсов и их названия:
0 - dgpu - gfx1010:xnack-
1 - igpu - Intel(R) HD Graphics 530
2 - cpu - Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz

| device-index |   n   | LOC_SIZE | Time(ms) |
|:------------:|:-----:|:--------:|:--------:|
| 0 (dgpu)     | 1024  | 2        | 0.0364   |
|              | 1024  | 4        | 0.02176  |
|              | 1024  | 8        | 0.01496  |
|              | 1024  | 16       | 0.01148  |
|              | 1024  | 32       | 0.00952  |
|              | 1024  | 64       | 0.00916  |
|              | 2048  | 2        | 0.08016  |
|              | 2048  | 4        | 0.03672  |
|              | 2048  | 8        | 0.022    |
|              | 2048  | 16       | 0.01468  |
|              | 2048  | 32       | 0.0114   |
|              | 2048  | 64       | 0.00952  |
|              | 4096  | 2        | 0.21592  |
|              | 4096  | 4        | 0.07912  |
|              | 4096  | 8        | 0.03656  |
|              | 4096  | 16       | 0.02216  |
|              | 4096  | 32       | 0.01492  |
|              | 4096  | 64       | 0.01152  |
|              | 8192  | 2        | 0.7002   |
|              | 8192  | 4        | 0.219    |
|              | 8192  | 8        | 0.0724   |
|              | 8192  | 16       | 0.03724  |
|              | 8192  | 32       | 0.02288  |
|              | 8192  | 64       | 0.01528  |
|              | 16384 | 2        | 2.46312  |
|              | 16384 | 4        | 0.69936  |
|              | 16384 | 8        | 0.22048  |
|              | 16384 | 16       | 0.07976  |
|              | 16384 | 32       | 0.03824  |
|              | 16384 | 64       | 0.02428  |
| 1 (igpu)     | 1024  | 2        | 0.268415 |
|              | 1024  | 4        | 0.086166 |
|              | 1024  | 8        | 0.035666 |
|              | 1024  | 16       | 0.018583 |
|              | 1024  | 32       | 0.014416 |
|              | 1024  | 64       | 0.012499 |
|              | 2048  | 2        | 0.945162 |
|              | 2048  | 4        | 0.270248 |
|              | 2048  | 8        | 0.106249 |
|              | 2048  | 16       | 0.036916 |
|              | 2048  | 32       | 0.018999 |
|              | 2048  | 64       | 0.014666 |
|              | 4096  | 2        | 3.57373  |
|              | 4096  | 4        | 0.936162 |
|              | 4096  | 8        | 0.273498 |
|              | 4096  | 16       | 0.094832 |
|              | 4096  | 32       | 0.037749 |
|              | 4096  | 64       | 0.023166 |
|              | 8192  | 2        | 13.8012  |
|              | 8192  | 4        | 3.62498  |
|              | 8192  | 8        | 0.948662 |
|              | 8192  | 16       | 0.274915 |
|              | 8192  | 32       | 0.090416 |
|              | 8192  | 64       | 0.047333 |
|              | 16384 | 2        | 53.9779  |
|              | 16384 | 4        | 13.6698  |
|              | 16384 | 8        | 3.58157  |
|              | 16384 | 16       | 0.948246 |
|              | 16384 | 32       | 0.331415 |
|              | 16384 | 64       | 0.125082 |
| 2 (cpu)      | 1024  | 2        | 0.3773   |
|              | 1024  | 4        | 0.2303   |
|              | 1024  | 8        | 0.0638   |
|              | 1024  | 16       | 0.0514   |
|              | 1024  | 32       | 0.0645   |
|              | 1024  | 64       | 0.0443   |
|              | 2048  | 2        | 0.5798   |
|              | 2048  | 4        | 0.4275   |
|              | 2048  | 8        | 0.1512   |
|              | 2048  | 16       | 0.0792   |
|              | 2048  | 32       | 0.0892   |
|              | 2048  | 64       | 0.0864   |
|              | 4096  | 2        | 1.8323   |
|              | 4096  | 4        | 1.0439   |
|              | 4096  | 8        | 0.2234   |
|              | 4096  | 16       | 0.1526   |
|              | 4096  | 32       | 0.1864   |
|              | 4096  | 64       | 0.137    |
|              | 8192  | 2        | 5.8176   |
|              | 8192  | 4        | 3.941    |
|              | 8192  | 8        | 0.5245   |
|              | 8192  | 16       | 0.2876   |
|              | 8192  | 32       | 0.2347   |
|              | 8192  | 64       | 0.3139   |
|              | 16384 | 2        | 22.1984  |
|              | 16384 | 4        | 14.5921  |
|              | 16384 | 8        | 1.0864   |
|              | 16384 | 16       | 0.6717   |
|              | 16384 | 32       | 0.5696   |
|              | 16384 | 64       | 0.2754   |

![dgpu_server](https://i.postimg.cc/TYTf05m1/dgpu1.png)
![igpu_server](https://i.postimg.cc/xTgY4jyR/igpu1.png)
![cpu_server](https://i.postimg.cc/MZ7z1mng/cpu1.png)

При увеличении размера локальной группы скорость также возрастает и с увеличением **n** скорость уменьшается. На сервере, в отличие от ноутбука, вычисления на серверном процессоре происходят без высокой погрешности. 

## *Вывод*

Вычисление префиксной суммы оказалось быстрее всего на дискретной видеокарте, так как она обладает большим количеством ядер, которые могут выполнять много операций одновременно. Поточная архитектура позволяет запускать множество потоков одновременно, что способствует эффективному вычислению при распараллеливании. Также видеокарты обладают высокой пропускной способностью памяти, что позволяет быстрее передавать данные между ядрами и памятью, что может быть позено для тех задач, которые требуют частого доступа к памяти. Из статей можно выяснить, что оказывается, видеокарты оснащены специализированными блоками для выполнения математических операций, что позволяет им быстрее выполнять вычисления по сравнению с процессорами (CPU), которые не имеют такой специализации 
https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda 
https://www.howtogeek.com/774789/cpu-vs-gpu-whats-the-difference/.

Интегрированные видеокарты и процессоры, хотя и могут выполнять подобные задачи, но они не обладают такой же степенью параллелизма и оптимизации для параллельных вычислений, как дискретные видеокарты. Поэтому они обычно медленнее при выполнении таких задач.
